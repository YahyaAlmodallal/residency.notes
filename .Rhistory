mutate(authorsservice = case_when(
is.na(authorsservice) | authorsservice == "" ~ "unknown",  # Checks for NA or empty strings and replaces with "unknown"
authorsservice %in% c("Pediatrics", "QuickCare") ~ "PED General",
authorsservice == "Psychiatry" ~ "PSY Child Psychiatry",
authorsservice == "MED Allergy/Immunology" ~ "PED Allergy/Immunology",
TRUE ~ authorsservice
)) %>%
mutate(notetype = case_when(
notetype %in% c("ED Provider Notes", "ED Notes") ~ "Emergency Department",
TRUE ~ notetype
)) %>%
# Change encountercontext values of "HOV"
mutate(encountercontext = if_else(encountercontext == "HOV", "Ambulatory", encountercontext)) %>%
# Set authorsservice for Emergency Department
mutate(authorsservice = if_else(encountercontext == "Emergency Department", "Emergency Department", authorsservice)) %>%
mutate(encountercontext = if_else(authorsservice == "Emergency Department", "Emergency Department", encountercontext)) %>%
mutate(notetype = if_else(encountercontext == "Emergency Department", "Emergency Department", notetype)) %>%
mutate(notetype = if_else(encountercontext == "Telephone Encounter", "Telephone Encounter", notetype)) %>%
# Update encountercontext for specific services
mutate(encountercontext = case_when(
(encountercontext %in% c("Ambulatory", "Inpatient") & authorsservice == "Emergency Department") ~ "Emergency Department",
TRUE ~ encountercontext
))%>%
# Remove unneeded columns
select(-noteactive, -`%***`)
# summary.1: raw data after some refining
summary.1 <- sum_df(all_data_1)
# Identifying notes with equal number of authors and edit times, excluding notes with unequal numbers, and identifying notes with no time data
# available and equal edit times and author information
all_data_2 <- all_data_1 %>%
mutate(
authorcount = str_count(author, "\n") + 1,
timecount = str_count(`edittime(seconds)`, "\n") + 1,
) %>%
filter(authorcount == timecount) %>%
select(-authorcount, -timecount)
# not equal number (too many edit instances)
not_equal <- all_data_1 %>%
mutate(
authorcount = str_count(author, "\n") + 1,
timecount = str_count(`edittime(seconds)`, "\n") + 1
) %>%
filter(authorcount != timecount) %>%
select(-authorcount, -timecount)
# not available edit time information
combined <- bind_rows(not_equal, all_data_2)
no_times <- anti_join(all_data_1, combined, by = "noteid")
all_exported_count = nrow(all_data_1)
after_deleteing_incomplete_data_count = nrow(all_data_2)
inequal_number_count = nrow(not_equal)
no_time_data_count = nrow(no_times)
print(nrow(all_data_1))
print(nrow(all_data_2))
print(nrow(not_equal))
print(nrow(no_times))
# The edit start and edit stop dates are not uniform, there were about 3000 values where the dates are shown as serial numbers, luckily these are easy to extract since each has a single editing instance
# Extract serial number dates and convert them back to actual dates, then calculate the time between the start and end of each note
filtered_data <- all_data_2 %>%
filter(grepl("^[0-9]+\\.?[0-9]*$", editstart), grepl("^[0-9]+\\.?[0-9]*$", editstop)) %>%
mutate(
editstart = as.POSIXct(as.Date(as.numeric(editstart), origin = "1899-12-30"), tz = "UTC"),
editstop = as.POSIXct(as.Date(as.numeric(editstop), origin = "1899-12-30"), tz = "UTC"),
starttostop = difftime(editstop, editstart, units = "hours"),
`edittime(seconds)` = as.numeric(`edittime(seconds)`)
)
# Remaining rows, to calculate the time between the start and end of these notes; will need to divide the contents of each row, convert them to date/time, then calculate the difference
# Step 1: Filter out rows in all_data_2 that match rows in filtered_data
all_data_2_remaining <- all_data_2 %>%
anti_join(filtered_data, by = "noteid") %>%
mutate(
first_editstart = sapply(strsplit(as.character(editstart), "\r\n"), `[`, 1),
last_editstop = sapply(strsplit(as.character(editstop), "\r\n"), tail, 1),
first_editstart = as.POSIXct(first_editstart, format = "%m/%d/%Y %I:%M:%S %p", tz = "UTC"),
last_editstop = as.POSIXct(last_editstop, format = "%m/%d/%Y %I:%M:%S %p", tz = "UTC"),
starttostop = difftime(last_editstop, first_editstart, units = "hours")
) %>%
select(-last_editstop, -first_editstart)
# Separate the editing instances into separate rows
all_data_3 <- all_data_2_remaining %>% separate_rows(editstart, editstop, author, 'edittime(seconds)', sep = "\r\n")
# Convert dates to proper format, then deal with NA values
all_data_3$dtofsvc <- as.POSIXct(all_data_3$dtofsvc, format="%m/%d/%Y %I:%M:%S %p")
all_data_3$filetime <- as.POSIXct(all_data_3$filetime, format="%m/%d/%Y %I:%M:%S %p")
all_data_3$editstart <- as.POSIXct(all_data_3$editstart, format="%m/%d/%Y %I:%M:%S %p")
all_data_3$editstop <- as.POSIXct(all_data_3$editstop, format="%m/%d/%Y %I:%M:%S %p")
all_data_3$`edittime(seconds)` <- as.numeric(all_data_3$`edittime(seconds)`)
# Now we can join the two dataframes, and double checks for NAs, zeros, or negative values
all_data_3 <- bind_rows(all_data_3, filtered_data)
# Replace 0 or negative values with NA
all_data_3$starttostop <- ifelse(all_data_3$starttostop <= 0, NA, all_data_3$starttostop)
# Check for NA values
na_count = sum(is.na(all_data_3$starttostop))
total_rows = nrow(all_data_3)
# Print the results
print(paste("Number of NA values: ", na_count))
# Adding the day and shift columns
all_data_3 <- all_data_3 %>%
mutate(day = weekdays(editstart)) %>%
mutate(shift = mapply(get_shift, encountercontext, editstart))
# Calculate the number of NAs in editstart and shift columns
editstart_na_count <- sum(is.na(all_data_3$editstart))
shift_na_count <- sum(is.na(all_data_3$shift))
# Count how many notes are from the Emergency Department
ed_notes_count <- sum(all_data_3$encountercontext == "Emergency Department")
# Check that all NAs are for ED notes and the count of NAs matches the count of ED notes
if (editstart_na_count == 0 && shift_na_count == ed_notes_count) {
print("All dates are appropriate and only ED notes have no assigned shift")
} else {
print("There is a discrepancy in the data. Not all NAs are for ED notes or the counts do not match.")
}
# Adding weekend, after hours (for ambulatory notes), and PM shift (for inpatient notes) columns
all_data_3 <- all_data_3 %>%
mutate(
weekend = if_else(day %in% c("Saturday", "Sunday"), `edittime(seconds)`, NA_real_),
after.hours = if_else(shift == "After work-hours", `edittime(seconds)`, NA_real_),
pm = if_else(shift == "PM shift", `edittime(seconds)`, NA_real_)
)
# Cleaning the author and note author columns and making sure every signing note author name is present as an author of the same note
# Clean the Author column (remove the [########] from the end of each name)
all_data_3 <- all_data_3 %>%
mutate(
author = gsub("\\s\\[\\d+\\]", "", author)
)
# Convert author and note author columns to lower case
all_data_3 <- all_data_3 %>%
mutate(
noteauthor = tolower(noteauthor),
author = tolower(author)
)
# Remove spaces at the end of each value, and remove everything after the 2nd comma (individual's degree)
all_data_4 <- all_data_3 %>%
mutate(noteauthor = sapply(str_split(noteauthor, ", "), function(x) paste(x[1:min(length(x), 2)], collapse = ", ")),
noteauthor = if_else(str_sub(noteauthor, -1, -1) == " ", str_sub(noteauthor, 1, str_length(noteauthor) - 1), noteauthor),
author = if_else(str_sub(author, -1, -1) == " ", str_sub(author, 1, str_length(author) - 1), author))
# Filter all rows where a unique note's signing author is not present in the authors' column
filtered_data <- all_data_4 %>%
group_by(noteid) %>%
filter(!noteauthor %in% author) %>%
ungroup()
# Take these rows out of the main dataframe, clean them, then join them back into the main dataframe
unfiltered <- all_data_4 %>%
anti_join(filtered_data, by = colnames(all_data_4))
nrow(filtered_data) + nrow(unfiltered) == nrow(all_data_4)
# Define the mapping of original values to new values
author_mapping <- c(
"bea..." = "beasley, gary s",
"colaizy, ..." = "colaizy, tarah t",
"dagle, jo..." = "dagle, john m",
"fontinel, amy l" = "stier, amy c",
"zhorne, derek j" = "weinstein, stuart l"
)
# Apply the mapping to the 'author' column
filtered_data <- filtered_data %>%
mutate(author = case_when(
author %in% names(author_mapping) ~ author_mapping[author],
TRUE ~ author
))
# Define the mapping of original values to new values for the noteauthor column
noteauthor_mapping <- c(
"abu hamad, moh" = "abu hamad, moh'd rawhi abdullah m r",
"abu hamad, moh'd rawhi a" = "abu hamad, moh'd rawhi abdullah m r",
"aguilar, agustin jr." = "aguilar, agustin",
"brown, adam l" = "brown, ashley",
"cornelius, kacie" = "rytlewski, kacie",
"daniels, elizabeth c" = "smet, elizabeth c",
"ebach, dawn" = "ebach, dawn r",
"haskell, sarah e" = "haskell, sarah",
"lee, samantha b" = "lee, samantha",
"lin-dyken, deborah" = "lin-dyken, deborah c",
"ma, melinda a" = "whitacre, melinda a",
"madthil, sujana" = "madathil, sujana",
"meyer, heather" = "schmuecker, heather m",
"newton, kristina" = "sobaski, kristina t",
"norris, andrew" = "norris, andrew w",
"ramsey, laura" = "ramsey, laura j",
"reasoner, andrea l" = "porter, andrea l",
"scheffler, stephanie m" = "james, stephanie s",
"smith-mccartney, lindsey m" = "ewan, lindsey m",
"springman, alexandra l" = "keating, alexandra l"
)
# Apply the mapping to the 'noteauthor' column
filtered_data <- filtered_data %>%
mutate(noteauthor = case_when(
noteauthor %in% names(noteauthor_mapping) ~ noteauthor_mapping[noteauthor],
noteauthor == "botos, madison" ~ "limke, wyatt l",
TRUE ~ noteauthor
))
# Now join the fixed filtered data and the unfiltered data
all_data_5 <- bind_rows(filtered_data, unfiltered)
nrow(all_data_5) == nrow(all_data_4)
# Check: Filter all rows where a unique note's signing author is not present in the authors' column; make sure rows are 0 now
any_issues <- all_data_5 %>%
group_by(noteid) %>%
filter(!noteauthor %in% author) %>%
ungroup()
nrow(any_issues) == 0
# Cleaning resident names, adjust specific residents with changed names to match those in 'resident.names'
# Create a mapping vector (those names are inspired from previous work in 2022, however, from exploring the current data, it seems that the only different name is that of springman, alexandra which is now keating, alexandra)
name_mapping <- c(
"abu hamad, moh" = "abu hamad, moh'd rawhi abdullah m r",
"mcintire, natalie" = "mcintire, natalie r",
"daniels, elizabeth c" = "smet, elizabeth c",
"stover, daniel" = "stover, daniel w",
"ma, melinda a" = "whitacre, melinda a",
"keating, alexandra l" = "springman, alexandra l",
"cornelius, kacie" = "rytlewski, kacie",
"rytlewski, kacie t" = "rytlewski, kacie"
)
# Apply the mapping to the 'noteauthor' and 'author' columns
all_data_6 <- all_data_5 %>%
mutate(author = case_when(
author %in% names(name_mapping) ~ name_mapping[author],
TRUE ~ author
)) %>%
mutate(noteauthor = case_when(
noteauthor %in% names(name_mapping) ~ name_mapping[noteauthor],
TRUE ~ noteauthor
))
# Cleaning author service and author type (this is based on work done in 9/2023 and extended here to include any new providers; the unique noteauthors were exported, and the author service, and type, adjusted manually to crate the true.author.service file)
# Join the file with the manually adjusted data to the main file
all_data_7 <- all_data_6 %>%
left_join(true.service, by = c("noteauthor" = "name")) %>%
# Update authorsservice
mutate(authorsservice = coalesce(authorsservice.y, authorsservice.x)) %>%
# Update authortype
mutate(authortype = coalesce(authortype.y, authortype.x)) %>%
# Remove the temporary .x and .y columns for both fields
select(-matches("\\.x$"), -matches("\\.y$")) %>%
# Update the authorservice to PED General if a reisdent wrote the note and the author service is NA
mutate(authorsservice = if_else(is.na(authorsservice) & authortype == "resident", "PED General", authorsservice))
# Check that all "attendings" are present in true.service
# Step 1: Filter attending authors in all_data_7
attending_authors <- all_data_7 %>%
filter(authortype == "attending") %>%
select(noteauthor) %>%
distinct()
# Step 2: Check against true.service names
unmatched_authors <- anti_join(attending_authors, true.service, by = c("noteauthor" = "name"))
# Step 3: Provide a warning if there are discrepancies
if(nrow(unmatched_authors) > 0) {
warning("Fix the author service for any new note authors")
print(unmatched_authors) # Optionally print out the unmatched authors for review
} else {
print("All attending note authors are correctly matched in true.service")
}
# Step 4: Provide a warning if there are discrepancies
if(nrow(all_data_3) != nrow(all_data_7)) {
warning("You have lost some rows while refining the data")
print(unmatched_authors) # Optionally print out the unmatched authors for review
} else {
print("You have not lost any rows while refining the data")
}
# Fixing the PED Nursery author service
all_data_8 <- all_data_7 %>%
mutate(
# Create a new column 'NNSY' based on specified conditions
nnsy = ifelse(
abs(difftime(dtofsvc, birthdate, units = "days")) <= 3 &
authorsservice %in% c("PED General", "PED Nursery", "Pediatrics") &
encountercontext %in% c("Inpatient") &
notetype != "Clinic Note",
"Yes",
"No"
)
) %>%
# Update 'Author.s.Service' for 'NNSY' = "Yes"
mutate(
authorsservice = ifelse(nnsy == "Yes", "PED Nursery", authorsservice),
) %>%
# Remove unneeded columns
select(-nnsy)
summary.6 = sum_df(all_data_8)
# Determine PGY for each resident and for each time interval
# Define the date ranges
date_21_start <- as.POSIXct("2021-07-01 00:00:00")
date_21_end <- as.POSIXct("2022-06-30 23:59:59")
date_22_start <- as.POSIXct("2022-07-01 00:00:00")
date_22_end <- as.POSIXct("2023-06-30 23:59:59")
date_23_start <- as.POSIXct("2023-07-01 00:00:00")
date_23_end <- as.POSIXct("2024-06-30 23:59:59")
before_end <- as.POSIXct("2021-06-30 23:59:59")
after_start <- as.POSIXct("2024-07-01 00:00:00")
# Filter the data based on the date ranges
data_21 <- all_data_8 %>% filter(editstart >= date_21_start & editstart <= date_21_end)
data_22 <- all_data_8 %>% filter(editstart >= date_22_start & editstart <= date_22_end)
data_23 <- all_data_8 %>% filter(editstart >= date_23_start & editstart <= date_23_end)
before <- all_data_8 %>% filter(editstart <= before_end)
after <- all_data_8 %>% filter(editstart >= after_start)
# Check that no values were missed
total_rows <- nrow(all_data_8)
filtered_rows <- nrow(data_21) + nrow(data_22) + nrow(data_23) + nrow(before) + nrow(after)
if(total_rows == filtered_rows) {
print("All rows have been accounted for.")
} else {
print("Some rows have been missed.")
}
# Apply conditions directly without a function
data_21 <- data_21 %>%
mutate(pgy = case_when(
author %in% resident.names$`PGY.3` ~ "pgy1.21.22",
author %in% resident.names$`PGY.4` ~ "pgy2.21.22",
author %in% resident.names$`PGY.5` ~ "pgy3.21.22",
TRUE ~ NA_character_
))
# Apply conditions directly without a function
data_22 <- data_22 %>%
mutate(pgy = case_when(
author %in% resident.names$`PGY.2` ~ "pgy1.22.23",
author %in% resident.names$`PGY.3` ~ "pgy2.22.23",
author %in% resident.names$`PGY.4` ~ "pgy3.22.23",
TRUE ~ NA_character_
))
# Apply conditions directly without a function
data_23 <- data_23 %>%
mutate(pgy = case_when(
author %in% resident.names$`PGY.1` ~ "pgy1.23.24",
author %in% resident.names$`PGY.2` ~ "pgy2.23.24",
author %in% resident.names$`PGY.3` ~ "pgy3.23.24",
TRUE ~ NA_character_
))
# join the 3 dataframes, leaving out those outside the date range
all_data_8 <- bind_rows(data_21, data_22, data_23)
outside_time_range_count = nrow(all_data_7) - nrow(data_21) - nrow(data_22) - nrow(data_23)
print(outside_time_range_count)
# Remove these rows from the original data frame
all_data_9 <- all_data_8 %>%
filter(
(`edittime(seconds)` > 3 & !author %in% staffs) |  # Handle edittime and author conditions
(`edittime(seconds)` > 0 & author %in% staffs)   # Handle edittime and author conditions
)
editing_time_insufficient_count = nrow(all_data_8) - nrow(all_data_9)
print(editing_time_insufficient_count)
all_data_9 <- all_data_9 %>%
filter((is.na(notesize) | notesize != 0))    # Keep notesize that are NA or not zero
empty_note_count = nrow(all_data_8) - editing_time_insufficient_count - nrow(all_data_9)
print(empty_note_count)
# These are unaccounted for since they are overlapped between the criteria above (e.g. <5 seconds and before 6/30/21)
removed = - nrow(all_data_9) + nrow(all_data_8)
print(removed)
summary.7 <- sum_df(all_data_9)
# Delete all notes where a resident did not have a true contribution (<5 seconds). We will group the dataframe by note id, then look at all the editing instances of each unique note id, and if the pgy column do not include one of the residents (all its values are), then will delete these note ids
filtered_data <- all_data_9 %>%
group_by(noteid) %>%
filter(!all(is.na(pgy))) %>%
ungroup()
# Columns to be deleted
cols_to_delete <- c("birthdate", "day", "editstart", "editstop",
"noteauthorlogindept", "noteauthornpi", "noteduration(physician)",
"noteduration(resident)", "shift", "specialtyatnote",
"specialtycurrent", "timediff(hr)")
# Delete specified columns
filtered_data <- filtered_data %>% select(-all_of(cols_to_delete))
cons.data <- filtered_data %>%
group_by(noteid) %>%
summarise(
total.time = sum(`edittime(seconds)`),
weekend = sum(weekend, na.rm = TRUE),
after.hours = sum(after.hours, na.rm = TRUE),
pm = sum(pm, na.rm = TRUE),
across(everything(), first),
.groups = "drop"
)
cons.data <- cons.data %>%
mutate(pm = ifelse(encountercontext != "Inpatient" & pm == 0, NA, pm),
after.hours = ifelse(encountercontext != "Ambulatory" & after.hours == 0, NA, after.hours))
# 2- attendings file (consolidated by ID, all attending edits for each note combined), delete unneeded columns
staff.data <- filtered_data %>%
filter(author %in% staffs) %>%
group_by(noteid) %>%
summarise(staff.time = sum(`edittime(seconds)`),
across(everything(), first),
.groups = "drop")
# 3- all residents file (consolidated by ID and class/resident, all notes), delete unneeded columns
all.resident.data <- filtered_data %>%
filter(pgy != "NA") %>%
group_by(noteid) %>%
summarise(resident.time = sum(`edittime(seconds)`),
across(everything(), first),
.groups = "drop")
# Join the resident and staff eidting time columns to the main dataframe
# Join staff.time from staff.data
cons.data <- cons.data %>%
left_join(staff.data %>% select(noteid, staff.time), by = "noteid")
# Join resident.time from resident.data
cons.data <- cons.data %>%
left_join(all.resident.data %>% select(noteid, resident.time), by = "noteid")
# Add contribution of resident percentage column
cons.data <- cons.data %>%
mutate(resident.percent = resident.time / total.time * 100)
# 4- Individual resident file (consolidated by residents)
per.resident <- filtered_data %>%
filter(pgy != "NA") %>%
group_by(noteid, author) %>%
summarise(
resident.time = sum(`edittime(seconds)`),
weekend = sum(weekend, na.rm = TRUE),
after.hours = sum(after.hours, na.rm = TRUE),
pm = sum(pm, na.rm = TRUE),
across(everything(), first),
.groups = "drop"
)
per.resident <- per.resident %>%
mutate(pm = ifelse(encountercontext != "Inpatient" & pm == 0, NA, pm),
after.hours = ifelse(encountercontext != "Ambulatory" & after.hours == 0, NA, after.hours))
# Summary statement
summary_messages <- c(
paste("At the beginning, there were", nrow(all_data_1), "notes. Out of these, notes with equal or incomplete edit time data counted", nrow(not_equal), "and", nrow(no_times), ", respectively.", na_count, "notes had incorrect times to calculate a start-to-stop value. The file was then separated for each edit instance resulting in", nrow(all_data_3), "instances, of which", nrow(all_data_8) - nrow(all_data_9), "were removed because these lasted <5 seconds and were not attending edits or lasted <1 second and were attending edits, or contained 0 characters.", nrow(before) + nrow(after), "editing instances were removed because they occurred before 7/1/21 or after 6/30/24. Further", nrow(all_data_9) - nrow(filtered_data), "editing instances were removed since there were no true resident contributions to the associated notes. The final note count after refinements is", nrow(cons.data), "meaning that", (nrow(all_data_2) - nrow(cons.data)), "notes were excluded while editing instances were refined."),
paste("Total number of excluded notes is (both numbers should be equal):", nrow(not_equal) + nrow(no_times) + (nrow(all_data_2) - nrow(cons.data)), nrow(all_data_1) - nrow(cons.data))
)
# To print the messages, you can then do:
print(summary_messages[1])  # Print first message
print(summary_messages[2])  # Print second message
saveRDS(filtered_data, file = "all_data.rds")
saveRDS(cons.data, file = "cons_data.rds")
saveRDS(per.resident, file = "per.resident.rds")
saveRDS(summary_messages, file = "summary_messages.rds")
z = sum_df(cons.data)
View(z)
View(cons.data)
# Remove these rows from the original data frame
all_data_9 <- all_data_8 %>%
filter(
(`edittime(seconds)` > 2 & !author %in% staffs) |  # Handle edittime and author conditions
(`edittime(seconds)` > 0 & author %in% staffs)   # Handle edittime and author conditions
)
editing_time_insufficient_count = nrow(all_data_8) - nrow(all_data_9)
print(editing_time_insufficient_count)
all_data_9 <- all_data_9 %>%
filter((is.na(notesize) | notesize != 0))    # Keep notesize that are NA or not zero
empty_note_count = nrow(all_data_8) - editing_time_insufficient_count - nrow(all_data_9)
print(empty_note_count)
# These are unaccounted for since they are overlapped between the criteria above (e.g. <5 seconds and before 6/30/21)
removed = - nrow(all_data_9) + nrow(all_data_8)
print(removed)
summary.7 <- sum_df(all_data_9)
# Delete all notes where a resident did not have a true contribution (<5 seconds). We will group the dataframe by note id, then look at all the editing instances of each unique note id, and if the pgy column do not include one of the residents (all its values are), then will delete these note ids
filtered_data <- all_data_9 %>%
group_by(noteid) %>%
filter(!all(is.na(pgy))) %>%
ungroup()
# Columns to be deleted
cols_to_delete <- c("birthdate", "day", "editstart", "editstop",
"noteauthorlogindept", "noteauthornpi", "noteduration(physician)",
"noteduration(resident)", "shift", "specialtyatnote",
"specialtycurrent", "timediff(hr)")
# Delete specified columns
filtered_data <- filtered_data %>% select(-all_of(cols_to_delete))
cons.data <- filtered_data %>%
group_by(noteid) %>%
summarise(
total.time = sum(`edittime(seconds)`),
weekend = sum(weekend, na.rm = TRUE),
after.hours = sum(after.hours, na.rm = TRUE),
pm = sum(pm, na.rm = TRUE),
across(everything(), first),
.groups = "drop"
)
cons.data <- cons.data %>%
mutate(pm = ifelse(encountercontext != "Inpatient" & pm == 0, NA, pm),
after.hours = ifelse(encountercontext != "Ambulatory" & after.hours == 0, NA, after.hours))
# 2- attendings file (consolidated by ID, all attending edits for each note combined), delete unneeded columns
staff.data <- filtered_data %>%
filter(author %in% staffs) %>%
group_by(noteid) %>%
summarise(staff.time = sum(`edittime(seconds)`),
across(everything(), first),
.groups = "drop")
# 3- all residents file (consolidated by ID and class/resident, all notes), delete unneeded columns
all.resident.data <- filtered_data %>%
filter(pgy != "NA") %>%
group_by(noteid) %>%
summarise(resident.time = sum(`edittime(seconds)`),
across(everything(), first),
.groups = "drop")
# Join the resident and staff eidting time columns to the main dataframe
# Join staff.time from staff.data
cons.data <- cons.data %>%
left_join(staff.data %>% select(noteid, staff.time), by = "noteid")
# Join resident.time from resident.data
cons.data <- cons.data %>%
left_join(all.resident.data %>% select(noteid, resident.time), by = "noteid")
# Add contribution of resident percentage column
cons.data <- cons.data %>%
mutate(resident.percent = resident.time / total.time * 100)
# 4- Individual resident file (consolidated by residents)
per.resident <- filtered_data %>%
filter(pgy != "NA") %>%
group_by(noteid, author) %>%
summarise(
resident.time = sum(`edittime(seconds)`),
weekend = sum(weekend, na.rm = TRUE),
after.hours = sum(after.hours, na.rm = TRUE),
pm = sum(pm, na.rm = TRUE),
across(everything(), first),
.groups = "drop"
)
per.resident <- per.resident %>%
mutate(pm = ifelse(encountercontext != "Inpatient" & pm == 0, NA, pm),
after.hours = ifelse(encountercontext != "Ambulatory" & after.hours == 0, NA, after.hours))
# Summary statement
summary_messages <- c(
paste("At the beginning, there were", nrow(all_data_1), "notes. Out of these, notes with equal or incomplete edit time data counted", nrow(not_equal), "and", nrow(no_times), ", respectively.", na_count, "notes had incorrect times to calculate a start-to-stop value. The file was then separated for each edit instance resulting in", nrow(all_data_3), "instances, of which", nrow(all_data_8) - nrow(all_data_9), "were removed because these lasted <5 seconds and were not attending edits or lasted <1 second and were attending edits, or contained 0 characters.", nrow(before) + nrow(after), "editing instances were removed because they occurred before 7/1/21 or after 6/30/24. Further", nrow(all_data_9) - nrow(filtered_data), "editing instances were removed since there were no true resident contributions to the associated notes. The final note count after refinements is", nrow(cons.data), "meaning that", (nrow(all_data_2) - nrow(cons.data)), "notes were excluded while editing instances were refined."),
paste("Total number of excluded notes is (both numbers should be equal):", nrow(not_equal) + nrow(no_times) + (nrow(all_data_2) - nrow(cons.data)), nrow(all_data_1) - nrow(cons.data))
)
# To print the messages, you can then do:
print(summary_messages[1])  # Print first message
print(summary_messages[2])  # Print second message
saveRDS(filtered_data, file = "all_data.rds")
saveRDS(cons.data, file = "cons_data.rds")
saveRDS(per.resident, file = "per.resident.rds")
saveRDS(summary_messages, file = "summary_messages.rds")
z
write(z, "zz.csv")
