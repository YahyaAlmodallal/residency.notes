qqline(sample_means, col = "red")
# Perform tests
ad_test <- ad.test(sample_means)
shapiro_test <- shapiro.test(sample_means)
# Store results
test_results <- rbind(test_results, data.frame(
variable = column,
transformation = trans_name,
ad_p_value = ad_test$p.value,
shapiro_p_value = shapiro_test$p.value
))
} else {
message(paste("Not enough valid data points for", column, "with transformation", trans_name))
}
}
}
return(test_results)
}
# Function to summarize times for each resident in the list of dataframes where each dataframe is the notes of a resident
calculate_statistics <- function(df) {
all_notes <- nrow(df)
inpatient_notes <- sum(df$encountercontext == "Inpatient")
ambulatory_notes <- sum(df$encountercontext == "Ambulatory")
ed_notes <- sum(df$encountercontext == "Emergency Department")
telephone_notes <- sum(df$encountercontext == "Telephone Encounter")
total_time_days <- sum(df$resident.time) / (60 * 60 * 24)
mean_time_mins <- exp(mean(log(df$resident.time / 60), na.rm = TRUE))
sd_time_mins <- exp(sd(log(df$resident.time / 60), na.rm = TRUE))
median_time_mins <- median(df$resident.time / 60)
max_time_mins <- max(df$resident.time / 60)
quantile_25th_time_mins <- quantile(df$resident.time / 60, probs = 0.25)
quantile_75th_time_mins <- quantile(df$resident.time / 60, probs = 0.75)
weekend_time_days <- sum(df$weekend) / (60 * 60 * 24)
percentage_weekend <- sum(df$weekend) / sum(df$resident.time) * 100
pm_time_days <- sum(df$pm) / (60 * 60 * 24)
percentage_pm <- sum(df$pm) / sum(df$resident.time) * 100
after_hours_time_days <- sum(df$after.hours) / (60 * 60 * 24)
percentage_after_hours <- sum(df$after.hours) / sum(df$resident.time) * 100
mean_note_size <- exp(mean(log(df$notesize), na.rm = TRUE))
sd_note_size <- exp(sd(log(df$notesize), na.rm = TRUE))
count_dictated <- sum(df$`%voice` > 0, na.rm = TRUE)
mean_dictation <- mean(df$`%voice`, na.rm = TRUE)
sd_dictation <- sd(df$`%voice`, na.rm = TRUE)
count_copied <- sum(df$`%copied` > 0, na.rm = TRUE)
mean_copied <- mean(df$`%copied`, na.rm = TRUE)
sd_copied <- sd(df$`%copied`, na.rm = TRUE)
# Specific mean times calculations with exponential and log transformation
mean_hp <- ifelse(any(df$notetype == "H&P"), exp(mean(log(df$resident.time[df$notetype == "H&P"] / 60), na.rm = TRUE)), NA)
mean_CN <- ifelse(any(df$notetype == "Clinic Note"), exp(mean(log(df$resident.time[df$notetype == "Clinic Note"] / 60), na.rm = TRUE)), NA)
mean_DS <- ifelse(any(df$notetype == "Discharge Summary"), exp(mean(log(df$resident.time[df$notetype == "Discharge Summary"] / 60), na.rm = TRUE)), NA)
mean_Cs <- ifelse(any(df$notetype == "Consults"), exp(mean(log(df$resident.time[df$notetype == "Consults"] / 60), na.rm = TRUE)), NA)
mean_PN <- ifelse(any(df$notetype == "Progress Notes"), exp(mean(log(df$resident.time[df$notetype == "Progress Notes"] / 60), na.rm = TRUE)), NA)
mean_TE <- ifelse(any(df$notetype == "Telephone Encounter"), exp(mean(log(df$resident.time[df$notetype == "Telephone Encounter"] / 60), na.rm = TRUE)), NA)
mean_ED <- ifelse(any(df$notetype == "Emergency Department"), exp(mean(log(df$resident.time[df$notetype == "Emergency Department"] / 60), na.rm = TRUE)), NA)
mean_P <- ifelse(any(df$notetype == "Procedures"), exp(mean(log(df$resident.time[df$notetype == "Procedures"] / 60), na.rm = TRUE)), NA)
smartphrase_mean <- mean(lengths(gregexpr("\\[", df$smartphraseids)), na.rm = TRUE)
time_to_complete_mean <- exp(mean(log(df$starttostop), na.rm = TRUE)) / 60 * 24
time_to_complete_sd <- exp(sd(log(df$starttostop), na.rm = TRUE))
number_copied_forward <- sum(df$iteration > 0, na.rm = TRUE)
mean_iteration <- mean(df$iteration, na.rm = TRUE)
sd_iteration <- sd(df$iteration, na.rm = TRUE)
# Create a dataframe of the computed values
data.frame(
'All.Notes' = all_notes,
'Inpatient' = inpatient_notes,
'Ambulatory' = ambulatory_notes,
EDNotes = ed_notes,
TelephoneNotes = telephone_notes,
TotalTimeDays = total_time_days,
Overall = mean_time_mins,
SDTimeMins = sd_time_mins,
MedianTimeMins = median_time_mins,
MaxTimeMins = max_time_mins,
IQR25th = quantile_25th_time_mins,
IQR75th = quantile_75th_time_mins,
WeekendTimeDays = weekend_time_days,
Weekend = percentage_weekend,
PMTimeDays = pm_time_days,
'Inpatient.PM' = percentage_pm,
AfterHoursTimeDays = after_hours_time_days,
'Ambulatory.After_Hours' = percentage_after_hours,
'Note.Size' = mean_note_size,
SDNoteSize = sd_note_size,
CountDictated = count_dictated,
'Percent.Dictated' = mean_dictation,
SDDictation = sd_dictation,
CountCopied = count_copied,
'Percent.Copied' = mean_copied,
SDCopied = sd_copied,
SmartphraseMean = smartphrase_mean,
'Days.to.Sign' = time_to_complete_mean,
TimeToCompleteSD = time_to_complete_sd,
NumberCopiedForward = number_copied_forward,
MeanIteration = mean_iteration,
SDIteration = sd_iteration,
'HP' = mean_hp,
'Clinic' = mean_CN,
'Discharge' = mean_DS,
'Consult' = mean_Cs,
'Progress' = mean_PN,
'Telephone' = mean_TE,
'ED' = mean_ED,
'Procedure' = mean_P
)
}
# Function to melt and create plots for specific variable groups without legend
create_melted_plot <- function(data, columns, title, x_label, y_label) {
melted_data <- melt(data[, c("PGY", columns)], id.vars = "PGY")
ggplot(melted_data, aes(x = variable, y = value, color = PGY)) +
geom_point(position = position_jitter(width = 0.2, height = 0)) +
labs(title = title, x = x_label, y = y_label) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1),
legend.position = "none")
}
cons.data <- readRDS("cons_data.rds")
# Calculate the logarithm of total time
cons.data <- cons.data %>%
mutate(smart_phrases_count = str_count(smartphraseids, "\\["))  # Count "[" in smartphraseids
# Applying log transformation to the predictors
cons.data <- cons.data %>%
mutate_at(vars(`%copied`, `%voice`, smart_phrases_count, weekend, pm, notesize, total.time,
resident.time, staff.time, iteration, starttostop, sources),
~ log1p(.))  # log1p is used to apply log(1 + x) to avoid log(0)
# Select relevant columns
selected_data <- cons.data %>%
select(total.time, `%copied`, `%voice`, smart_phrases_count, weekend,
pm, notesize, resident.time, staff.time, iteration, starttostop,
sources, resident.percent)
# Calculate correlation matrix
correlation_matrix <- cor(selected_data, method = "pearson", use = "complete.obs")  # Handles missing values by listwise deletion
print(correlation_matrix)
# Melting the correlation matrix into a long format
melted_corr_matrix <- melt(correlation_matrix)
# Plotting the heatmap
x = ggplot(data = melted_corr_matrix, aes(x = Var1, y = Var2, fill = value)) +
geom_tile() +
geom_text(aes(label = sprintf("%.2f", value)), size = 3, color = "black") +
scale_fill_gradient2(low = "blue", high = "red", mid = "white", midpoint = 0, limit = c(-1,1)) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1),
axis.text.y = element_text(angle = 0, hjust = 1)) +
labs(title = "Heatmap of Pearson Correlation with Coefficients", x = "", y = "", fill = "Correlation")
ggsave("xx.png", plot = x, width = 14, height = 12)
# Sampling a subset of the data, for example 10% of the rows
sampled_data <- selected_data[sample(nrow(selected_data), size = 0.1 * nrow(selected_data)),]
# Creating the matrix of scatter plots with slope lines in the lower triangle
c <- ggpairs(sampled_data,
columns = c("total.time", "%copied", "%voice", "weekend", "pm", "notesize", "resident.time", "staff.time", "starttostop", "resident.percent"),
lower = list(continuous = function(data, mapping, ...) {
ggplot(data = data, mapping = mapping) +
geom_point(color = "blue") +
geom_smooth(method = "lm", color = "red", se = FALSE)
}),
upper = list(continuous = "cor"),
diag = list(continuous = "barDiag"))
# Viewing the plot (if needed)
print(c)
cons.data <- readRDS("cons_data.rds")
# Calculate the logarithm of total time
cons.data <- cons.data %>%
mutate(smart_phrases_count = str_count(smartphraseids, "\\["))  # Count "[" in smartphraseids
# Create a new column "other.time"
cons.data <- cons.data %>%
mutate(other.time = total.time - staff.time - resident.time)
# Applying log transformation to the predictors
cons.data <- cons.data %>%
mutate_at(vars(weekend, pm, notesize, total.time, after.hours, resident.time, staff.time, other.time, starttostop),
~ log1p(.))  # log1p is used to apply log(1 + x) to avoid log(0)
# Select relevant columns
selected_data <- cons.data %>%
select(total.time, `%copied`, `%voice`, weekend, pm, notesize, resident.time, staff.time, other.time, starttostop, resident.percent)
# Calculate correlation matrix
correlation_matrix <- cor(selected_data, method = "pearson", use = "complete.obs")  # Handles missing values by listwise deletion
print(correlation_matrix)
# Melting the correlation matrix into a long format
melted_corr_matrix <- melt(correlation_matrix)
# Plotting the heatmap
x = ggplot(data = melted_corr_matrix, aes(x = Var1, y = Var2, fill = value)) +
geom_tile() +
geom_text(aes(label = sprintf("%.2f", value)), size = 3, color = "black") +
scale_fill_gradient2(low = "blue", high = "red", mid = "white", midpoint = 0, limit = c(-1,1)) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1),
axis.text.y = element_text(angle = 0, hjust = 1)) +
labs(title = "Heatmap of Pearson Correlation with Coefficients", x = "", y = "", fill = "Correlation")
ggsave("xx.png", plot = x, width = 14, height = 12)
# Sampling a subset of the data, for example 10% of the rows
sampled_data <- selected_data[sample(nrow(selected_data), size = 0.1 * nrow(selected_data)),]
# Creating the matrix of scatter plots with slope lines in the lower triangle
c <- ggpairs(sampled_data,
columns = c("total.time", "%copied", "%voice", "weekend", "pm", "notesize", "resident.time", "staff.time", "starttostop", "resident.percent", "after.hours", "other.time"),
lower = list(continuous = function(data, mapping, ...) {
ggplot(data = data, mapping = mapping) +
geom_point(color = "blue") +
geom_smooth(method = "lm", color = "red", se = FALSE)
}),
upper = list(continuous = "cor"),
diag = list(continuous = "barDiag"))
cons.data <- readRDS("cons_data.rds")
# Calculate the logarithm of total time
cons.data <- cons.data %>%
mutate(smart_phrases_count = str_count(smartphraseids, "\\["))  # Count "[" in smartphraseids
# Create a new column "other.time"
cons.data <- cons.data %>%
mutate(other.time = total.time - staff.time - resident.time)
# Applying log transformation to the predictors
cons.data <- cons.data %>%
mutate_at(vars(weekend, pm, notesize, total.time, after.hours, resident.time, staff.time, other.time, starttostop),
~ log1p(.))  # log1p is used to apply log(1 + x) to avoid log(0)
# Select relevant columns
selected_data <- cons.data %>%
select(total.time, `%copied`, `%voice`, weekend, pm, notesize, resident.time, staff.time, other.time, starttostop, resident.percent, after.hours)
# Calculate correlation matrix
correlation_matrix <- cor(selected_data, method = "pearson", use = "complete.obs")  # Handles missing values by listwise deletion
View(selected_data)
str(selected_data)
# Calculate correlation matrix
correlation_matrix <- cor(selected_data, method = "pearson", use = "pairwise.complete.obs")  # Handles missing values by listwise deletion
print(correlation_matrix)
# Melting the correlation matrix into a long format
melted_corr_matrix <- melt(correlation_matrix)
# Plotting the heatmap
x = ggplot(data = melted_corr_matrix, aes(x = Var1, y = Var2, fill = value)) +
geom_tile() +
geom_text(aes(label = sprintf("%.2f", value)), size = 3, color = "black") +
scale_fill_gradient2(low = "blue", high = "red", mid = "white", midpoint = 0, limit = c(-1,1)) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1),
axis.text.y = element_text(angle = 0, hjust = 1)) +
labs(title = "Heatmap of Pearson Correlation with Coefficients", x = "", y = "", fill = "Correlation")
ggsave("xx.png", plot = x, width = 14, height = 12)
# Sampling a subset of the data, for example 10% of the rows
sampled_data <- selected_data[sample(nrow(selected_data), size = 0.1 * nrow(selected_data)),]
# Creating the matrix of scatter plots with slope lines in the lower triangle
c <- ggpairs(sampled_data,
columns = c("total.time", "%copied", "%voice", "weekend", "pm", "notesize", "resident.time", "staff.time", "starttostop", "resident.percent", "after.hours", "other.time"),
lower = list(continuous = function(data, mapping, ...) {
ggplot(data = data, mapping = mapping) +
geom_point(color = "blue") +
geom_smooth(method = "lm", color = "red", se = FALSE)
}),
upper = list(continuous = "cor"),
diag = list(continuous = "barDiag"))
# Viewing the plot (if needed)
print(c)
# Creating the matrix of scatter plots with slope lines in the lower triangle
c <- ggpairs(selected_data,
columns = c("total.time", "%copied", "%voice", "weekend", "pm", "notesize", "resident.time", "staff.time", "starttostop", "resident.percent", "after.hours", "other.time"),
lower = list(continuous = function(data, mapping, ...) {
ggplot(data = data, mapping = mapping) +
geom_point(color = "blue") +
geom_smooth(method = "lm", color = "red", se = FALSE)
}),
upper = list(continuous = "cor"),
diag = list(continuous = "barDiag"))
# Viewing the plot (if needed)
print(c)
# Creating the matrix of scatter plots with slope lines in the lower triangle
c <- ggpairs(selected_data,
columns = c("total.time", "%copied", "%voice", "weekend", "pm", "notesize", "resident.time", "staff.time", "starttostop", "resident.percent", "after.hours", "other.time"),
lower = list(continuous = function(data, mapping, ...) {
ggplot(data = data, mapping = mapping) +
geom_point(color = "blue") +
geom_smooth(method = "lm", color = "red", se = FALSE)
}),
upper = list(continuous = "cor"),
diag = list(continuous = "barDiag"))
# Viewing the plot (if needed)
print(c)
colnames(selected_data)
# Saving the plot
ggsave("cc.png", plot = c, width = 14, height = 12)
# Simplified to check for errors
c <- ggpairs(selected_data,
columns = c("total.time", "%copied", "%voice", "weekend", "pm", "notesize", "resident.time", "staff.time", "starttostop", "resident.percent", "after.hours"),
lower = list(continuous = wrap("points", colour = "blue") +
wrap("smooth", method = "lm", colour = "red", se = FALSE)),
upper = list(continuous = "cor"),
diag = list(continuous = "barDiag"))
c <- ggpairs(selected_data,
columns = c("total.time", "%copied", "%voice", "weekend", "pm", "notesize",
"resident.time", "staff.time", "starttostop", "resident.percent", "after.hours"),
lower = list(continuous = function(data, mapping, ...) {
ggplot(data = data, mapping = mapping) +
geom_point(color = "blue") +
geom_smooth(method = "lm", color = "red", se = FALSE)
}),
upper = list(continuous = "cor"),
diag = list(continuous = "barDiag"))
# Viewing the plot (if needed)
print(c)
# Creating the matrix of scatter plots with slope lines in the lower triangle
c <- ggpairs(selected_data,
columns = c("total.time", "%copied", "%voice", "weekend", "notesize", "resident.time", "staff.time", "starttostop", "resident.percent", "after.hours", "other.time"),
lower = list(continuous = function(data, mapping, ...) {
ggplot(data = data, mapping = mapping) +
geom_point(color = "blue") +
geom_smooth(method = "lm", color = "red", se = FALSE)
}),
upper = list(continuous = "cor"),
diag = list(continuous = "barDiag"))
# Viewing the plot (if needed)
print(c)
cons.data <- readRDS("cons_data.rds")
# Applying multiple transformations in a single pipeline
cons.data <- cons.data %>%
# Count "[" in smartphraseids to get the number of smart phrases used
mutate(smart_phrases_count = str_count(smartphraseids, "\\[")) %>%
# Calculate 'other.time' as 'total.time' minus 'staff.time' and 'resident.time'
mutate(other.time = total.time - staff.time - resident.time) %>%
# Create 'outside.work.hours' by combining 'pm' and 'weekend' where the first non-NA value is chosen
mutate(outside.work.hours = coalesce(pm, after.hours)) %>%
# Apply log1p transformation to multiple variables
mutate_at(vars(outside.work.hours, notesize, total.time, weekend,
resident.time, staff.time, other.time, starttostop),
~ log1p(.))  # log1p to handle zeros by transforming log(1 + x)
# Select relevant columns for further analysis
selected_data <- cons.data %>%
select(total.time, `%copied`, `%voice`, outside.work.hours, notesize,
resident.time, staff.time, other.time, starttostop, resident.percent, weekend)
# Calculate correlation matrix
correlation_matrix <- cor(selected_data, method = "pearson", use = "complete.obs")  # Handles missing values by listwise deletion
print(correlation_matrix)
# Melting the correlation matrix into a long format
melted_corr_matrix <- melt(correlation_matrix)
# Plotting the heatmap
x = ggplot(data = melted_corr_matrix, aes(x = Var1, y = Var2, fill = value)) +
geom_tile() +
geom_text(aes(label = sprintf("%.2f", value)), size = 3, color = "black") +
scale_fill_gradient2(low = "blue", high = "red", mid = "white", midpoint = 0, limit = c(-1,1)) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1),
axis.text.y = element_text(angle = 0, hjust = 1)) +
labs(title = "Heatmap of Pearson Correlation with Coefficients", x = "", y = "", fill = "Correlation")
ggsave("xx.png", plot = x, width = 14, height = 12)
# Creating the matrix of scatter plots with slope lines in the lower triangle
c <- ggpairs(selected_data,
columns = c("total.time", "%copied", "%voice", "outside.work.hours", "notesize", "resident.time", "staff.time", "starttostop", "resident.percent", "weekend", "other.time"),
lower = list(continuous = function(data, mapping, ...) {
ggplot(data = data, mapping = mapping) +
geom_point(color = "blue") +
geom_smooth(method = "lm", color = "red", se = FALSE)
}),
upper = list(continuous = "cor"),
diag = list(continuous = "barDiag"))
# Viewing the plot (if needed)
print(c)
# Saving the plot
ggsave("cc.png", plot = c, width = 14, height = 12)
z = ggplot(data = melted_correlation_matrix, aes(Var1, Var2, fill = value)) +
geom_tile() +
geom_text(aes(label = sprintf("%.2f", value)), color = "black") +
scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0,
limits = c(-1, 1),
breaks = seq(-1, 1, by = 0.2),
oob = scales::oob_squish) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
labs(fill = "Correlation")
z = ggplot(data = melted_corr_matrix, aes(Var1, Var2, fill = value)) +
geom_tile() +
geom_text(aes(label = sprintf("%.2f", value)), color = "black") +
scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0,
limits = c(-1, 1),
breaks = seq(-1, 1, by = 0.2),
oob = scales::oob_squish) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
labs(fill = "Correlation")
print(z)
# Define a custom function for coloring based on correlation values
custom_cor <- function(data, mapping, ...){
cor_res <- cor(data[[mapping$x]], data[[mapping$y]], use="complete.obs")
color <- ifelse(abs(cor_res) > 0.2, "red", "black") # Red if |r| > 0.2, otherwise black
ggplot(data = data, mapping = mapping) +
geom_text(aes(label = sprintf("%.2f", cor_res)), color = color)
}
# Create the ggpairs plot with custom coloring for correlations
c <- ggpairs(selected_data,
columns = c("total.time", "%copied", "%voice", "outside.work.hours", "notesize", "resident.time", "staff.time", "starttostop", "resident.percent", "weekend", "other.time"),
lower = list(continuous = function(data, mapping, ...) {
ggplot(data = data, mapping = mapping) +
geom_point(color = "blue") +
geom_smooth(method = "lm", color = "red", se = FALSE)
}),
upper = list(continuous = custom_cor),
diag = list(continuous = "barDiag"))
# Save the plot
ggsave("cc_highlighted.png", plot = c, width = 14, height = 12)
# Define a custom function for coloring based on correlation values
custom_cor <- function(data, mapping, ...){
# Extract the columns directly from the data using the names provided by 'mapping'
x_col <- eval(mapping$x, envir = data)
y_col <- eval(mapping$y, envir = data)
# Calculate correlation
cor_res <- cor(x_col, y_col, use = "complete.obs")
# Set color based on correlation threshold
color <- ifelse(abs(cor_res) > 0.2, "red", "black")
# Create the plot
ggplot(data = data, aes_string(x = mapping$x, y = mapping$y)) +
geom_text(label = sprintf("%.2f", cor_res), color = color)
}
# Create the ggpairs plot with custom coloring for correlations
c <- ggpairs(selected_data,
columns = c("total.time", "%copied", "%voice", "outside.work.hours", "notesize", "resident.time", "staff.time", "starttostop", "resident.percent", "weekend", "other.time"),
lower = list(continuous = function(data, mapping, ...) {
ggplot(data = data, mapping = mapping) +
geom_point(color = "blue") +
geom_smooth(method = "lm", color = "red", se = FALSE)
}),
upper = list(continuous = custom_cor),
diag = list(continuous = "barDiag"))
# Save the plot
ggsave("cc_highlighted.png", plot = c, width = 14, height = 12)
# Define a custom function for coloring based on correlation values
custom_cor <- function(data, mapping, ...){
# Extract the columns directly from the data using the names provided by 'mapping'
x_col <- eval(mapping$x, envir = data)
y_col <- eval(mapping$y, envir = data)
# Ensure columns are numeric
if (!is.numeric(x_col) || !is.numeric(y_col)) {
return(ggplot() + geom_blank() +
annotate("text", x = 0.5, y = 0.5, label = "Non-numeric data", color = "red"))
}
# Calculate correlation
cor_res <- cor(x_col, y_col, use = "complete.obs")
# Set color based on correlation threshold
color <- ifelse(abs(cor_res) > 0.2, "red", "black")
# Create the plot
ggplot(data = data, aes_string(x = mapping$x, y = mapping$y)) +
geom_text(label = sprintf("%.2f", cor_res), color = color)
}
# Create the ggpairs plot with custom coloring for correlations
c <- ggpairs(selected_data,
columns = c("total.time", "%copied", "%voice", "outside.work.hours", "notesize", "resident.time", "staff.time", "starttostop", "resident.percent", "weekend", "other.time"),
lower = list(continuous = function(data, mapping, ...) {
ggplot(data = data, mapping = mapping) +
geom_point(color = "blue") +
geom_smooth(method = "lm", color = "red", se = FALSE)
}),
upper = list(continuous = custom_cor),
diag = list(continuous = "barDiag"))
# Create the ggpairs plot with custom coloring for correlations
c <- ggpairs(selected_data,
columns = c("total.time", "%copied", "%voice", "outside.work.hours", "notesize", "resident.time", "staff.time", "starttostop", "resident.percent", "weekend", "other.time"),
lower = list(continuous = function(data, mapping, ...) {
ggplot(data = data, mapping = mapping) +
geom_point(color = "blue") +
geom_smooth(method = "lm", color = "red", se = FALSE)
}),
upper = list(continuous = custom_cor),
diag = list(continuous = "barDiag"))
# Save the plot
ggsave("cc_highlighted.png", plot = c, width = 14, height = 12)
View(cons.data)
#Clean environment and free memory
rm(list = ls())
gc()
setwd("C:\\Users\\yahya\\OneDrive\\Research\\residency.notes\\Script")
save_path <- "C:\\Users\\yahya\\OneDrive\\Research\\residency.notes\\Script\\Script cache and figures\\Cache"
knitr::opts_chunk$set(
echo = FALSE,
warning = FALSE,
message = FALSE,
fig.width = 10,
fig.height = 8,
cache = TRUE,
cache.path = save_path,
fig.path = save_path
)
#Set number of digits to display
options(digits = 5, scipen = 999)
#Packages and Libraries
library(ggplot2)
library(tidyverse)
library(lubridate)
library(readr)
library(conflicted)
library(dplyr)
library(htmltools)
library(skimr)
library(janitor)
library(gt)
library(tidyr)
library(stringdist)
library(purrr)
library(report)
library(grid)
library(stringr)
library(gridExtra)
library(MASS)
library(knitr)
library(tools)
library(kableExtra)
library(DT)
library(broom)
library(htmlwidgets)
library(webshot)
library(extrafont)
library(ragg)
library(plotly)
library(pagedown)
library(readxl)
library(rlang)
library(nortest)
library(glue)
library(reshape2)
library(GGally)
library(boot)
conflict_prefer("select", "dplyr")
conflicts_prefer(dplyr::filter)  # Set conflict resolution preferences
